; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 942] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\SDRAM\2410lib.o --depend=.\SDRAM\2410lib.d --device=DARMSS9 --apcs=interwork -O0 -I..\Common\Inc -I.\Include -ID:\Keil\ARM\INC\Samsung --omf_browse=.\SDRAM\2410lib.crf ..\common\src\2410lib.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  port_init PROC
;;;50         //Binary : *0     1       1      1,     1      1      1      1,     1      1      1      1         
;;;51         rGPACON = 0x5fbfff;
000000  e59f03a0          LDR      r0,|L1.936|
000004  e3a01456          MOV      r1,#0x56000000
000008  e5810000          STR      r0,[r1,#0]
;;;52     
;;;53         //===* PORT B GROUP
;;;54         //Ports  : GPB10  GPB9   GPB8   GPB7   GPB6   GPB5    GPB4    GPB3   GPB2   GPB1  GPB0
;;;55         //Signal : LED4   LED3   LED2   LED1   GPB6  DIS_OFF L3CLOCK L3DATA  L3MODE PWM2  PWM1
;;;56         //Setting: Output Output Output Output Output Output  Output  Output Output TOUT1 TOUT0 
;;;57         //Binary : 01,    01     *01,   *01    *01,   01      01,     01     01,    10    10  
;;;58         rGPBCON = 0x155559;
00000c  e59f0398          LDR      r0,|L1.940|
000010  e5810010          STR      r0,[r1,#0x10]
;;;59         rGPBUP  = 0x7ff;      // The pull up function is disabled GPB[10:0]
000014  e59f0394          LDR      r0,|L1.944|
000018  e5810018          STR      r0,[r1,#0x18]
;;;60     
;;;61         //=== PORT C GROUP
;;;62         //Ports  : GPC15 GPC14 GPC13 GPC12 GPC11 GPC10 GPC9 GPC8 GPC7   GPC6   GPC5   GPC4 GPC3   GPC2  GPC1 GPC0
;;;63         //Signal : VD7   VD6   VD5   VD4   VD3   VD2   VD1  VD0  Output Output Output OUT   VFRAME VLINE VCLK LEND  
;;;64         //Binary : 10    10,   10    10,   10    10,   10   10,  *01    *01,   *01    01,  10     10,   10   10
;;;65         rGPCCON = 0xaaaa55aa;       
00001c  e59f0390          LDR      r0,|L1.948|
000020  e5810020          STR      r0,[r1,#0x20]
;;;66         rGPCUP  = 0xffff;     // The pull up function is disabled GPC[15:0] 
000024  e0200460          EOR      r0,r0,r0,ROR #8
000028  e5810028          STR      r0,[r1,#0x28]
;;;67     
;;;68         //=== PORT D GROUP
;;;69         //Ports  : GPD15 GPD14 GPD13 GPD12 GPD11 GPD10 GPD9 GPD8 GPD7 GPD6 GPD5 GPD4 GPD3 GPD2 GPD1 GPD0
;;;70         //Signal : VD23  VD22  VD21  VD20  VD19  VD18  VD17 VD16 VD15 VD14 VD13 VD12 VD11 VD10 VD9  VD8
;;;71         //Binary : 10    10,   10    10,   10    10,   10   10,  10   10,  10   10,  10   10,  10   10
;;;72         rGPDCON = 0xaaaaaaaa;       
00002c  e59f0384          LDR      r0,|L1.952|
000030  e5810030          STR      r0,[r1,#0x30]
;;;73         rGPDUP  = 0xffff;     // The pull up function is disabled GPD[15:0]
000034  e59f0380          LDR      r0,|L1.956|
000038  e5810038          STR      r0,[r1,#0x38]
;;;74     
;;;75         //=== PORT E GROUP
;;;76         //Ports  : GPE15  GPE14  GPE13  GPE12   GPE11   GPE10   GPE9    GPE8     GPE7  GPE6  GPE5   GPE4  
;;;77         //Signal : IICSDA IICSCL SPICLK SPIMOSI SPIMISO SDDATA3 SDDATA2 SDDATA1 SDDATA0 SDCMD SDCLK I2SSDO 
;;;78         //Binary : 10     10,    10     10,     10      10,     10      10,      10    10,   10     10,       
;;;79         //----------------------------------------------------------------------------------------
;;;80         //Ports  :  GPE3   GPE2  GPE1    GPE0    
;;;81         //Signal : I2SSDI CDCLK I2SSCLK I2SLRCK     
;;;82         //Binary :  10     10,    10      10 
;;;83         rGPECON = 0xa6aaaaaa;       
00003c  e59f037c          LDR      r0,|L1.960|
000040  e5810040          STR      r0,[r1,#0x40]
;;;84         rGPEUP  = 0xffff;     // The pull up function is disabled GPE[15:0]
000044  e59f0370          LDR      r0,|L1.956|
000048  e5810048          STR      r0,[r1,#0x48]
;;;85     	rGPEDAT = 0x2000;
00004c  e3a00a02          MOV      r0,#0x2000
000050  e5810044          STR      r0,[r1,#0x44]
;;;86         //=== PORT F GROUP
;;;87         //Ports  : GPF7   GPF6   GPF5   GPF4   GPF3    GPF2      GPF1    GPF0
;;;88         //Signal : EINT7  EINT6  EINT5  EINT4  EINT3   EINT2     EINT1   EINT0
;;;89         //Setting: EINT7  EINT6  EINT5  EINT4  EINT3   EINT2     EINT1   EINT0
;;;90         //Binary : 10      10,     10     10,   10      10,       10      10
;;;91         rGPFCON = 0xaaaa;
000054  e59f0368          LDR      r0,|L1.964|
000058  e5810050          STR      r0,[r1,#0x50]
;;;92         rGPFUP  = 0xff;     // The pull up function is disabled GPF[7:0]
00005c  e3a000ff          MOV      r0,#0xff
000060  e5810058          STR      r0,[r1,#0x58]
;;;93     
;;;94         //=== PORT G GROUP
;;;95         //Ports  : GPG15 GPG14 GPG13 GPG12 GPG11  GPG10  GPG9      GPG8      GPG7    GPG6    
;;;96         //Signal : nYPON YMON  nXPON XMON  GPG11  SD_CD  CPLD_INT3 CPLD_INT2 SPICLK1 SPIMOSI
;;;97         //Setting: nYPON YMON  nXPON XMON  Output Iutput EINT17    EINT17    SPICLK1 SPIMOSI1
;;;98         //Binary : 11    11,   11    11,   01     00,    10        10,       11      11
;;;99         //---------------------------------------------------------------------------------------
;;;100        //Ports  : GPG5     GPG4      GPG3     GPG2 GPG1    GPG0    
;;;101        //Signal : SPIMISO1 LCD_PWREN BUT_INT2 nSS0 NET_INT GPG0
;;;102        //Setting: SPIMISO1 LCD_PWRDN EINT11   nSS0 EINT9   Output
;;;103        //Binary : 11       11,       10       11,  10      *01
;;;104        rGPGCON = 0xff46f7b9;
000064  e59f035c          LDR      r0,|L1.968|
000068  e5810060          STR      r0,[r1,#0x60]
;;;105        rGPGUP  = 0xffff;    // The pull up function is disabled GPG[15:0]
00006c  e59f0348          LDR      r0,|L1.956|
000070  e5810068          STR      r0,[r1,#0x68]
;;;106    
;;;107        //rGPGCON = (rGPGCON & 0xfffffcff) | (1<<8);	// GPG4 [9:8] 11  -> LCD_PWREN Enable
;;;108        // Eable LCD 
;;;109        // rGPGDAT = (rGPGDAT & 0xffef) | (1<<4);
;;;110        // close LCD 
;;;111        rGPGDAT = rGPGDAT & 0xffcf;
000074  e3a00456          MOV      r0,#0x56000000
000078  e5900064          LDR      r0,[r0,#0x64]
00007c  e59f1348          LDR      r1,|L1.972|
000080  e0000001          AND      r0,r0,r1
000084  e3a01456          MOV      r1,#0x56000000
000088  e5810064          STR      r0,[r1,#0x64]
;;;112    
;;;113        //=== PORT H GROUP
;;;114        //Ports  : GPH10 GPH9     GPH8   GPH7  GPH6  GPH5 GPH4 GPH3 GPH2 GPH1  GPH0 
;;;115        //Signal : GPH10  CLKOUT0 SD_WP  CTS1  RTS1  RXD1 TXD1 RXD0 TXD0 nRTS0 nCTS0
;;;116        //Setting: Output CLKOUT0 GPH8   nCTS1 nRTS1 RXD1 TXD1 RXD0 TXD0 nRTS0 nCTS0
;;;117        //Binary : 10,    10      10,    11    11,   10   10,  10   10,  10    10
;;;118        rGPHCON = 0x2aaaaa;
00008c  e59f033c          LDR      r0,|L1.976|
000090  e5810070          STR      r0,[r1,#0x70]
;;;119        rGPHUP  = 0x7ff;    // The pull up function is disabled GPH[10:0]
000094  e59f0314          LDR      r0,|L1.944|
000098  e5810078          STR      r0,[r1,#0x78]
;;;120        
;;;121    }
00009c  e12fff1e          BX       lr
;;;122    
                          ENDP

                  uart_change_baud PROC
;;;132    void uart_change_baud(int nChannel, int nBaud)
;;;133    {
0000a0  e92d4030          PUSH     {r4,r5,lr}
0000a4  e24dd01c          SUB      sp,sp,#0x1c
0000a8  e1a04000          MOV      r4,r0
0000ac  e1a05001          MOV      r5,r1
;;;134        if (nChannel == UART0)
0000b0  e3540000          CMP      r4,#0
0000b4  1a000013          BNE      |L1.264|
;;;135    	    rUBRDIV0=( (int)(PCLK/16./nBaud + 0.5) -1 );
0000b8  e1a00005          MOV      r0,r5
0000bc  ebfffffe          BL       __aeabi_i2d
0000c0  e58d0010          STR      r0,[sp,#0x10]
0000c4  e58d1014          STR      r1,[sp,#0x14]
0000c8  e1a03001          MOV      r3,r1
0000cc  e1a02000          MOV      r2,r0
0000d0  e28f0fbf          ADR      r0,|L1.980|
0000d4  e8900003          LDM      r0,{r0,r1}
0000d8  ebfffffe          BL       __aeabi_ddiv
0000dc  e58d0008          STR      r0,[sp,#8]
0000e0  e58d100c          STR      r1,[sp,#0xc]
0000e4  e28f0e2f          ADR      r0,|L1.988|
0000e8  e890000c          LDM      r0,{r2,r3}
0000ec  e59d0008          LDR      r0,[sp,#8]
0000f0  ebfffffe          BL       __aeabi_dadd
0000f4  e88d0003          STM      sp,{r0,r1}
0000f8  ebfffffe          BL       __aeabi_d2iz
0000fc  e2400001          SUB      r0,r0,#1
000100  e3a01205          MOV      r1,#0x50000000
000104  e5810028          STR      r0,[r1,#0x28]
                  |L1.264|
;;;136        
;;;137        if (nChannel == UART1)
000108  e3540001          CMP      r4,#1
00010c  1a00000e          BNE      |L1.332|
;;;138    	    rUBRDIV1=( (int)(PCLK/16./nBaud) -1 );
000110  e1a00005          MOV      r0,r5
000114  ebfffffe          BL       __aeabi_i2d
000118  e58d0010          STR      r0,[sp,#0x10]
00011c  e58d1014          STR      r1,[sp,#0x14]
000120  e1a03001          MOV      r3,r1
000124  e1a02000          MOV      r2,r0
000128  e28f0fa9          ADR      r0,|L1.980|
00012c  e8900003          LDM      r0,{r0,r1}
000130  ebfffffe          BL       __aeabi_ddiv
000134  e58d0008          STR      r0,[sp,#8]
000138  e58d100c          STR      r1,[sp,#0xc]
00013c  ebfffffe          BL       __aeabi_d2iz
000140  e2400001          SUB      r0,r0,#1
000144  e59f1298          LDR      r1,|L1.996|
000148  e5810028          STR      r0,[r1,#0x28]
                  |L1.332|
;;;139    
;;;140        if (nChannel == UART2)
00014c  e35400bb          CMP      r4,#0xbb
000150  1a00000e          BNE      |L1.400|
;;;141    	    rUBRDIV2=( (int)(PCLK/16./nBaud) -1 );
000154  e1a00005          MOV      r0,r5
000158  ebfffffe          BL       __aeabi_i2d
00015c  e58d0010          STR      r0,[sp,#0x10]
000160  e58d1014          STR      r1,[sp,#0x14]
000164  e1a03001          MOV      r3,r1
000168  e1a02000          MOV      r2,r0
00016c  e28f0e26          ADR      r0,|L1.980|
000170  e8900003          LDM      r0,{r0,r1}
000174  ebfffffe          BL       __aeabi_ddiv
000178  e58d0008          STR      r0,[sp,#8]
00017c  e58d100c          STR      r1,[sp,#0xc]
000180  ebfffffe          BL       __aeabi_d2iz
000184  e2400001          SUB      r0,r0,#1
000188  e59f1258          LDR      r1,|L1.1000|
00018c  e5810028          STR      r0,[r1,#0x28]
                  |L1.400|
;;;142    }
000190  e28dd01c          ADD      sp,sp,#0x1c
000194  e8bd4030          POP      {r4,r5,lr}
000198  e12fff1e          BX       lr
;;;143    
                          ENDP

                  delay PROC
;;;562    void delay(int nTime)
;;;563    {
00019c  e92d4070          PUSH     {r4-r6,lr}
0001a0  e1a04000          MOV      r4,r0
;;;564          // time=0: adjust the Delay function by WatchDog timer.
;;;565          // time>0: the number of loop time
;;;566          // resolution of time is 100us.
;;;567        int i,adjust=0;
0001a4  e3a06000          MOV      r6,#0
;;;568        if(nTime==0)
0001a8  e3540000          CMP      r4,#0
0001ac  1a00000c          BNE      |L1.484|
;;;569        {
;;;570            nTime   = 200;
0001b0  e3a040c8          MOV      r4,#0xc8
;;;571            adjust = 1;
0001b4  e3a06001          MOV      r6,#1
;;;572            delayLoopCount = 400;
0001b8  e3a00e19          MOV      r0,#0x190
0001bc  e59f1228          LDR      r1,|L1.1004|
0001c0  e5810000          STR      r0,[r1,#0]  ; delayLoopCount
;;;573    		//PCLK/1M,Watch-dog disable,1/64,interrupt disable,reset disable
;;;574            rWTCON = ((PCLK/1000000-1)<<8)|(2<<3); 
0001c4  e2800dbe          ADD      r0,r0,#0x2f80
0001c8  e3a01453          MOV      r1,#0x53000000
0001cc  e5810000          STR      r0,[r1,#0]
;;;575            rWTDAT = 0xffff;                             	//for first update
0001d0  e0660806          RSB      r0,r6,r6,LSL #16
0001d4  e5810004          STR      r0,[r1,#4]
;;;576            rWTCNT = 0xffff;                             	//resolution=64us @any PCLK 
0001d8  e5810008          STR      r0,[r1,#8]
;;;577            rWTCON = ((PCLK/1000000-1)<<8)|(2<<3)|(1<<5); 	//Watch-dog timer start
0001dc  e59f020c          LDR      r0,|L1.1008|
0001e0  e5810000          STR      r0,[r1,#0]
                  |L1.484|
;;;578        }
;;;579        for(;nTime>0;nTime--)
0001e4  ea000007          B        |L1.520|
                  |L1.488|
;;;580            for(i=0;i<delayLoopCount;i++);
0001e8  e3a05000          MOV      r5,#0
0001ec  ea000000          B        |L1.500|
                  |L1.496|
0001f0  e2855001          ADD      r5,r5,#1
                  |L1.500|
0001f4  e59f01f0          LDR      r0,|L1.1004|
0001f8  e5900000          LDR      r0,[r0,#0]  ; delayLoopCount
0001fc  e1550000          CMP      r5,r0
000200  bafffffa          BLT      |L1.496|
000204  e2444001          SUB      r4,r4,#1              ;579
                  |L1.520|
000208  e3540000          CMP      r4,#0                 ;579
00020c  cafffff5          BGT      |L1.488|
;;;581        if(adjust==1)
000210  e3560001          CMP      r6,#1
000214  1a00000b          BNE      |L1.584|
;;;582        {
;;;583            rWTCON = ((PCLK/1000000-1)<<8)|(2<<3);   		//Watch-dog timer stop
000218  e59f01d4          LDR      r0,|L1.1012|
00021c  e3a01453          MOV      r1,#0x53000000
000220  e5810000          STR      r0,[r1,#0]
;;;584            i = 0xffff - rWTCNT;                     		//1count->64us, 200*400 cycle runtime = 64*i us
000224  e3a00453          MOV      r0,#0x53000000
000228  e5900008          LDR      r0,[r0,#8]
00022c  e59f1188          LDR      r1,|L1.956|
000230  e0415000          SUB      r5,r1,r0
;;;585            delayLoopCount = 8000000/(i*64);         		//200*400:64*i=1*x:100 -> x=80000*100/(64*i)   
000234  e1a01305          LSL      r1,r5,#6
000238  e59f01b8          LDR      r0,|L1.1016|
00023c  ebfffffe          BL       __aeabi_idivmod
000240  e59f11a4          LDR      r1,|L1.1004|
000244  e5810000          STR      r0,[r1,#0]  ; delayLoopCount
                  |L1.584|
;;;586        }
;;;587    }
000248  e8bd4070          POP      {r4-r6,lr}
00024c  e12fff1e          BX       lr
;;;588    
                          ENDP

                  uart_init PROC
;;;154    void uart_init(int nMainClk, int nBaud, int nChannel)
;;;155    {
000250  e92d40f0          PUSH     {r4-r7,lr}
000254  e24dd02c          SUB      sp,sp,#0x2c
000258  e1a04000          MOV      r4,r0
00025c  e1a05001          MOV      r5,r1
000260  e1a06002          MOV      r6,r2
;;;156        int i;
;;;157        
;;;158        if(nMainClk == 0)
000264  e3540000          CMP      r4,#0
000268  1a000000          BNE      |L1.624|
;;;159        nMainClk    = PCLK;
00026c  e59f4188          LDR      r4,|L1.1020|
                  |L1.624|
;;;160    
;;;161        switch (nChannel)
000270  e3560000          CMP      r6,#0
000274  0a000004          BEQ      |L1.652|
000278  e3560001          CMP      r6,#1
00027c  0a000028          BEQ      |L1.804|
000280  e35600bb          CMP      r6,#0xbb
000284  1a000080          BNE      |L1.1164|
000288  ea00005f          B        |L1.1036|
                  |L1.652|
;;;162        {
;;;163        	case UART0: 
00028c  e1a00000          MOV      r0,r0
;;;164    			rUFCON0 = 0x0;   //UART channel 0 FIFO control register, FIFO disable
000290  e3a00000          MOV      r0,#0
000294  e3a01205          MOV      r1,#0x50000000
000298  e5810008          STR      r0,[r1,#8]
;;;165    			rUMCON0 = 0x0;   //UART chaneel 0 MODEM control register, AFC disable
00029c  e581000c          STR      r0,[r1,#0xc]
;;;166    			rULCON0 = 0x3;   //Line control register : Normal,No parity,1 stop,8 bits
0002a0  e3a00003          MOV      r0,#3
0002a4  e5810000          STR      r0,[r1,#0]
;;;167    	// [10]       [9]     [8]     [7]          [6]      [5]        [4]         [3:2]          [1:0]
;;;168    	// Clock Sel, Tx Int, Rx Int, Rx Time Out, Rx err,  Loop-back, Send break, Transmit Mode, Receive Mode
;;;169    	// 0          1       0,      0            1        0          0,          01             01
;;;170    	// PCLK       Level   Pulse   Disable      Generate Normal     Normal      Interrupt or Polling
;;;171    			rUCON0  = 0x245;								// Control register
0002a8  e59f0150          LDR      r0,|L1.1024|
0002ac  e5810004          STR      r0,[r1,#4]
;;;172    	//		rUBRDIV0=( (int)(nMainClk/16./nBaud) -1 );		// Baud rate divisior register 0
;;;173    			rUBRDIV0=( (int)(nMainClk/16./nBaud+0.5) -1 );	// Baud rate divisior register 0    
0002b0  e1a00005          MOV      r0,r5
0002b4  ebfffffe          BL       __aeabi_i2d
0002b8  e58d0020          STR      r0,[sp,#0x20]
0002bc  e58d1024          STR      r1,[sp,#0x24]
0002c0  e1a00004          MOV      r0,r4
0002c4  ebfffffe          BL       __aeabi_i2d
0002c8  e58d0018          STR      r0,[sp,#0x18]
0002cc  e58d101c          STR      r1,[sp,#0x1c]
0002d0  e28f0f4b          ADR      r0,|L1.1028|
0002d4  e890000c          LDM      r0,{r2,r3}
0002d8  e59d0018          LDR      r0,[sp,#0x18]
0002dc  ebfffffe          BL       __aeabi_ddiv
0002e0  e58d0010          STR      r0,[sp,#0x10]
0002e4  e58d1014          STR      r1,[sp,#0x14]
0002e8  e59d2020          LDR      r2,[sp,#0x20]
0002ec  e59d3024          LDR      r3,[sp,#0x24]
0002f0  ebfffffe          BL       __aeabi_ddiv
0002f4  e58d0008          STR      r0,[sp,#8]
0002f8  e58d100c          STR      r1,[sp,#0xc]
0002fc  e28f00d8          ADR      r0,|L1.988|
000300  e890000c          LDM      r0,{r2,r3}
000304  e59d0008          LDR      r0,[sp,#8]
000308  ebfffffe          BL       __aeabi_dadd
00030c  e88d0003          STM      sp,{r0,r1}
000310  ebfffffe          BL       __aeabi_d2iz
000314  e2400001          SUB      r0,r0,#1
000318  e3a01205          MOV      r1,#0x50000000
00031c  e5810028          STR      r0,[r1,#0x28]
;;;174    			break;
000320  ea00005b          B        |L1.1172|
                  |L1.804|
;;;175    			
;;;176    		case UART1: 
000324  e1a00000          MOV      r0,r0
;;;177    			rUFCON1 = 0x0;   //UART channel 1 FIFO control register, FIFO disable
000328  e3a00000          MOV      r0,#0
00032c  e59f10b0          LDR      r1,|L1.996|
000330  e5810008          STR      r0,[r1,#8]
;;;178    			rUMCON1 = 0x0;   //UART chaneel 1 MODEM control register, AFC disable
000334  e581000c          STR      r0,[r1,#0xc]
;;;179    			rULCON1 = 0x3;
000338  e3a00003          MOV      r0,#3
00033c  e5810000          STR      r0,[r1,#0]
;;;180    			rUCON1  = 0x245;
000340  e59f00b8          LDR      r0,|L1.1024|
000344  e5810004          STR      r0,[r1,#4]
;;;181    			rUBRDIV1=( (int)(nMainClk/16./nBaud) -1 );
000348  e1a00005          MOV      r0,r5
00034c  ebfffffe          BL       __aeabi_i2d
000350  e58d0020          STR      r0,[sp,#0x20]
000354  e58d1024          STR      r1,[sp,#0x24]
000358  e1a00004          MOV      r0,r4
00035c  ebfffffe          BL       __aeabi_i2d
000360  e58d0018          STR      r0,[sp,#0x18]
000364  e58d101c          STR      r1,[sp,#0x1c]
000368  e28f0094          ADR      r0,|L1.1028|
00036c  e890000c          LDM      r0,{r2,r3}
000370  e59d0018          LDR      r0,[sp,#0x18]
000374  ebfffffe          BL       __aeabi_ddiv
000378  e58d0010          STR      r0,[sp,#0x10]
00037c  e58d1014          STR      r1,[sp,#0x14]
000380  e59d2020          LDR      r2,[sp,#0x20]
000384  e59d3024          LDR      r3,[sp,#0x24]
000388  ebfffffe          BL       __aeabi_ddiv
00038c  e58d0008          STR      r0,[sp,#8]
000390  e58d100c          STR      r1,[sp,#0xc]
000394  ebfffffe          BL       __aeabi_d2iz
000398  e2400001          SUB      r0,r0,#1
00039c  e59f1040          LDR      r1,|L1.996|
0003a0  e5810028          STR      r0,[r1,#0x28]
;;;182    			break;
0003a4  ea00003a          B        |L1.1172|
                  |L1.936|
0003a8  005fbfff          DCD      0x005fbfff
                  |L1.940|
0003ac  00155559          DCD      0x00155559
                  |L1.944|
0003b0  000007ff          DCD      0x000007ff
                  |L1.948|
0003b4  aaaa55aa          DCD      0xaaaa55aa
                  |L1.952|
0003b8  aaaaaaaa          DCD      0xaaaaaaaa
                  |L1.956|
0003bc  0000ffff          DCD      0x0000ffff
                  |L1.960|
0003c0  a6aaaaaa          DCD      0xa6aaaaaa
                  |L1.964|
0003c4  0000aaaa          DCD      0x0000aaaa
                  |L1.968|
0003c8  ff46f7b9          DCD      0xff46f7b9
                  |L1.972|
0003cc  0000ffcf          DCD      0x0000ffcf
                  |L1.976|
0003d0  002aaaaa          DCD      0x002aaaaa
                  |L1.980|
0003d4  00000000
0003d8  41482cf7          DCFD     0x41482cf700000000 ; 3168750
                  |L1.988|
0003dc  00000000
0003e0  3fe00000          DCFD     0x3fe0000000000000 ; 0.5
                  |L1.996|
0003e4  50004000          DCD      0x50004000
                  |L1.1000|
0003e8  50008000          DCD      0x50008000
                  |L1.1004|
0003ec  00000000          DCD      ||.data||
                  |L1.1008|
0003f0  00003130          DCD      0x00003130
                  |L1.1012|
0003f4  00003110          DCD      0x00003110
                  |L1.1016|
0003f8  007a1200          DCD      0x007a1200
                  |L1.1020|
0003fc  03059ee0          DCD      0x03059ee0
                  |L1.1024|
000400  00000245          DCD      0x00000245
                  |L1.1028|
000404  00000000
000408  40300000          DCFD     0x4030000000000000 ; 16
                  |L1.1036|
;;;183    			
;;;184        	case UART2: 
00040c  e1a00000          MOV      r0,r0
;;;185    			rULCON2 = 0x3;
000410  e3a00003          MOV      r0,#3
000414  e51f1034          LDR      r1,|L1.1000|
000418  e5810000          STR      r0,[r1,#0]
;;;186    			rUCON2  = 0x245;
00041c  e51f0024          LDR      r0,|L1.1024|
000420  e5810004          STR      r0,[r1,#4]
;;;187    			rUBRDIV2=( (int)(nMainClk/16./nBaud) -1 );    
000424  e1a00005          MOV      r0,r5
000428  ebfffffe          BL       __aeabi_i2d
00042c  e58d0020          STR      r0,[sp,#0x20]
000430  e58d1024          STR      r1,[sp,#0x24]
000434  e1a00004          MOV      r0,r4
000438  ebfffffe          BL       __aeabi_i2d
00043c  e58d0018          STR      r0,[sp,#0x18]
000440  e58d101c          STR      r1,[sp,#0x1c]
000444  e24f0048          ADR      r0,|L1.1028|
000448  e890000c          LDM      r0,{r2,r3}
00044c  e59d0018          LDR      r0,[sp,#0x18]
000450  ebfffffe          BL       __aeabi_ddiv
000454  e58d0010          STR      r0,[sp,#0x10]
000458  e58d1014          STR      r1,[sp,#0x14]
00045c  e59d2020          LDR      r2,[sp,#0x20]
000460  e59d3024          LDR      r3,[sp,#0x24]
000464  ebfffffe          BL       __aeabi_ddiv
000468  e58d0008          STR      r0,[sp,#8]
00046c  e58d100c          STR      r1,[sp,#0xc]
000470  ebfffffe          BL       __aeabi_d2iz
000474  e2400001          SUB      r0,r0,#1
000478  e51f1098          LDR      r1,|L1.1000|
00047c  e5810028          STR      r0,[r1,#0x28]
;;;188    			rUFCON2 = 0x0;   //UART channel 2 FIFO control register, FIFO disable
000480  e3a00000          MOV      r0,#0
000484  e5810008          STR      r0,[r1,#8]
;;;189    			break;
000488  ea000001          B        |L1.1172|
                  |L1.1164|
;;;190    			
;;;191    		default:
00048c  e1a00000          MOV      r0,r0
;;;192    			break;
000490  e1a00000          MOV      r0,r0
                  |L1.1172|
000494  e1a00000          MOV      r0,r0                 ;174
;;;193    	}
;;;194    
;;;195        for(i=0;i<100;i++);
000498  e3a07000          MOV      r7,#0
00049c  ea000000          B        |L1.1188|
                  |L1.1184|
0004a0  e2877001          ADD      r7,r7,#1
                  |L1.1188|
0004a4  e3570064          CMP      r7,#0x64
0004a8  bafffffc          BLT      |L1.1184|
;;;196        delay(400);
0004ac  e3a00e19          MOV      r0,#0x190
0004b0  ebfffffe          BL       delay
;;;197    }
0004b4  e28dd02c          ADD      sp,sp,#0x2c
0004b8  e8bd40f0          POP      {r4-r7,lr}
0004bc  e12fff1e          BX       lr
;;;198    
                          ENDP

                  uart_select PROC
;;;208    {
;;;209        f_nWhichUart=nChannel;
0004c0  e59f1550          LDR      r1,|L1.2584|
0004c4  e5810000          STR      r0,[r1,#0]  ; f_nWhichUart
;;;210    }
0004c8  e12fff1e          BX       lr
;;;211    
                          ENDP

                  uart_txempty PROC
;;;221    {
;;;222        if(nChannel==0)
0004cc  e3500000          CMP      r0,#0
0004d0  1a000005          BNE      |L1.1260|
;;;223            while(!(rUTRSTAT0 & 0x4)); //Wait until tx shifter is empty.
0004d4  e1a00000          MOV      r0,r0
                  |L1.1240|
0004d8  e3a01205          MOV      r1,#0x50000000
0004dc  e5911010          LDR      r1,[r1,#0x10]
0004e0  e3110004          TST      r1,#4
0004e4  0afffffb          BEQ      |L1.1240|
0004e8  ea00000e          B        |L1.1320|
                  |L1.1260|
;;;224              
;;;225        else if(nChannel==1)
0004ec  e3500001          CMP      r0,#1
0004f0  1a000005          BNE      |L1.1292|
;;;226            while(!(rUTRSTAT1 & 0x4)); //Wait until tx shifter is empty.
0004f4  e1a00000          MOV      r0,r0
                  |L1.1272|
0004f8  e51f111c          LDR      r1,|L1.996|
0004fc  e5911010          LDR      r1,[r1,#0x10]
000500  e3110004          TST      r1,#4
000504  0afffffb          BEQ      |L1.1272|
000508  ea000006          B        |L1.1320|
                  |L1.1292|
;;;227            
;;;228        else if(nChannel==2)
00050c  e3500002          CMP      r0,#2
000510  1a000004          BNE      |L1.1320|
;;;229            while(!(rUTRSTAT2 & 0x4)); //Wait until tx shifter is empty.
000514  e1a00000          MOV      r0,r0
                  |L1.1304|
000518  e51f1138          LDR      r1,|L1.1000|
00051c  e5911010          LDR      r1,[r1,#0x10]
000520  e3110004          TST      r1,#4
000524  0afffffb          BEQ      |L1.1304|
                  |L1.1320|
;;;230    }
000528  e12fff1e          BX       lr
;;;231    
                          ENDP

                  uart_getch PROC
;;;241    {
;;;242        if(f_nWhichUart==0)
00052c  e59f04e4          LDR      r0,|L1.2584|
000530  e5900000          LDR      r0,[r0,#0]  ; f_nWhichUart
000534  e3500000          CMP      r0,#0
000538  1a000007          BNE      |L1.1372|
;;;243        {       
;;;244            while(!(rUTRSTAT0 & 0x1)); //Receive data ready
00053c  e1a00000          MOV      r0,r0
                  |L1.1344|
000540  e3a00205          MOV      r0,#0x50000000
000544  e5900010          LDR      r0,[r0,#0x10]
000548  e3100001          TST      r0,#1
00054c  0afffffb          BEQ      |L1.1344|
;;;245            return RdURXH0();
000550  e3a00205          MOV      r0,#0x50000000
000554  e5d00024          LDRB     r0,[r0,#0x24]
                  |L1.1368|
;;;246        }
;;;247        else if(f_nWhichUart==1)
;;;248        {       
;;;249            while(!(rUTRSTAT1 & 0x1)); //Receive data ready
;;;250            return RdURXH1();
;;;251        }
;;;252        else if(f_nWhichUart==2)
;;;253        {
;;;254            while(!(rUTRSTAT2 & 0x1)); //Receive data ready
;;;255            return RdURXH2();
;;;256        }
;;;257    	return NULL;
;;;258    }
000558  e12fff1e          BX       lr
                  |L1.1372|
00055c  e59f04b4          LDR      r0,|L1.2584|
000560  e5900000          LDR      r0,[r0,#0]            ;247  ; f_nWhichUart
000564  e3500001          CMP      r0,#1                 ;247
000568  1a000007          BNE      |L1.1420|
00056c  e1a00000          MOV      r0,r0                 ;249
                  |L1.1392|
000570  e51f0194          LDR      r0,|L1.996|
000574  e5900010          LDR      r0,[r0,#0x10]         ;249
000578  e3100001          TST      r0,#1                 ;249
00057c  0afffffb          BEQ      |L1.1392|
000580  e51f01a4          LDR      r0,|L1.996|
000584  e5d00024          LDRB     r0,[r0,#0x24]         ;250
000588  eafffff2          B        |L1.1368|
                  |L1.1420|
00058c  e59f0484          LDR      r0,|L1.2584|
000590  e5900000          LDR      r0,[r0,#0]            ;252  ; f_nWhichUart
000594  e3500002          CMP      r0,#2                 ;252
000598  1a000007          BNE      |L1.1468|
00059c  e1a00000          MOV      r0,r0                 ;254
                  |L1.1440|
0005a0  e51f01c0          LDR      r0,|L1.1000|
0005a4  e5900010          LDR      r0,[r0,#0x10]         ;254
0005a8  e3100001          TST      r0,#1                 ;254
0005ac  0afffffb          BEQ      |L1.1440|
0005b0  e51f01d0          LDR      r0,|L1.1000|
0005b4  e5d00024          LDRB     r0,[r0,#0x24]         ;255
0005b8  eaffffe6          B        |L1.1368|
                  |L1.1468|
0005bc  e3a00000          MOV      r0,#0                 ;257
0005c0  eaffffe4          B        |L1.1368|
;;;259    
                          ENDP

                  uart_getkey PROC
;;;269    {
;;;270        if(f_nWhichUart==0)
0005c4  e59f044c          LDR      r0,|L1.2584|
0005c8  e5900000          LDR      r0,[r0,#0]  ; f_nWhichUart
0005cc  e3500000          CMP      r0,#0
0005d0  1a000008          BNE      |L1.1528|
;;;271        {       
;;;272            if(rUTRSTAT0 & 0x1)    //Receive data ready
0005d4  e3a00205          MOV      r0,#0x50000000
0005d8  e5900010          LDR      r0,[r0,#0x10]
0005dc  e3100001          TST      r0,#1
0005e0  0a000002          BEQ      |L1.1520|
;;;273                return RdURXH0();
0005e4  e3a00205          MOV      r0,#0x50000000
0005e8  e5d00024          LDRB     r0,[r0,#0x24]
                  |L1.1516|
;;;274            else
;;;275                return 0;
;;;276        }
;;;277        else if(f_nWhichUart==1)
;;;278        {
;;;279            if(rUTRSTAT1 & 0x1)    //Receive data ready
;;;280                return RdURXH1();
;;;281            else
;;;282                return 0;
;;;283        }
;;;284        else if(f_nWhichUart==2)
;;;285        {       
;;;286            if(rUTRSTAT2 & 0x1)    //Receive data ready
;;;287                return RdURXH2();
;;;288            else
;;;289                return 0;
;;;290        }    
;;;291    	return NULL;
;;;292    }
0005ec  e12fff1e          BX       lr
                  |L1.1520|
0005f0  e3a00000          MOV      r0,#0                 ;275
0005f4  eafffffc          B        |L1.1516|
                  |L1.1528|
0005f8  e59f0418          LDR      r0,|L1.2584|
0005fc  e5900000          LDR      r0,[r0,#0]            ;277  ; f_nWhichUart
000600  e3500001          CMP      r0,#1                 ;277
000604  1a000008          BNE      |L1.1580|
000608  e51f022c          LDR      r0,|L1.996|
00060c  e5900010          LDR      r0,[r0,#0x10]         ;279
000610  e3100001          TST      r0,#1                 ;279
000614  0a000002          BEQ      |L1.1572|
000618  e51f023c          LDR      r0,|L1.996|
00061c  e5d00024          LDRB     r0,[r0,#0x24]         ;280
000620  eafffff1          B        |L1.1516|
                  |L1.1572|
000624  e3a00000          MOV      r0,#0                 ;282
000628  eaffffef          B        |L1.1516|
                  |L1.1580|
00062c  e59f03e4          LDR      r0,|L1.2584|
000630  e5900000          LDR      r0,[r0,#0]            ;284  ; f_nWhichUart
000634  e3500002          CMP      r0,#2                 ;284
000638  1a000008          BNE      |L1.1632|
00063c  e51f025c          LDR      r0,|L1.1000|
000640  e5900010          LDR      r0,[r0,#0x10]         ;286
000644  e3100001          TST      r0,#1                 ;286
000648  0a000002          BEQ      |L1.1624|
00064c  e51f026c          LDR      r0,|L1.1000|
000650  e5d00024          LDRB     r0,[r0,#0x24]         ;287
000654  eaffffe4          B        |L1.1516|
                  |L1.1624|
000658  e3a00000          MOV      r0,#0                 ;289
00065c  eaffffe2          B        |L1.1516|
                  |L1.1632|
000660  e3a00000          MOV      r0,#0                 ;291
000664  eaffffe0          B        |L1.1516|
;;;293    
                          ENDP

                  uart_sendbyte PROC
;;;404    void uart_sendbyte(int nData)
;;;405    {
000668  e92d4010          PUSH     {r4,lr}
00066c  e1a04000          MOV      r4,r0
;;;406        if(f_nWhichUart==0)
000670  e59f03a0          LDR      r0,|L1.2584|
000674  e5900000          LDR      r0,[r0,#0]  ; f_nWhichUart
000678  e3500000          CMP      r0,#0
00067c  1a000015          BNE      |L1.1752|
;;;407        {
;;;408            if(nData=='\n')
000680  e354000a          CMP      r4,#0xa
000684  1a000009          BNE      |L1.1712|
;;;409            {
;;;410                while(!(rUTRSTAT0 & 0x2));
000688  e1a00000          MOV      r0,r0
                  |L1.1676|
00068c  e3a00205          MOV      r0,#0x50000000
000690  e5900010          LDR      r0,[r0,#0x10]
000694  e3100002          TST      r0,#2
000698  0afffffb          BEQ      |L1.1676|
;;;411                delay(10);					//because the slow response of hyper_terminal 
00069c  e3a0000a          MOV      r0,#0xa
0006a0  ebfffffe          BL       delay
;;;412                WrUTXH0('\r');
0006a4  e3a0000d          MOV      r0,#0xd
0006a8  e3a01205          MOV      r1,#0x50000000
0006ac  e5c10020          STRB     r0,[r1,#0x20]
                  |L1.1712|
;;;413            }
;;;414            while(!(rUTRSTAT0 & 0x2));		//Wait until THR is empty.
0006b0  e1a00000          MOV      r0,r0
                  |L1.1716|
0006b4  e3a00205          MOV      r0,#0x50000000
0006b8  e5900010          LDR      r0,[r0,#0x10]
0006bc  e3100002          TST      r0,#2
0006c0  0afffffb          BEQ      |L1.1716|
;;;415            delay(10);
0006c4  e3a0000a          MOV      r0,#0xa
0006c8  ebfffffe          BL       delay
;;;416            WrUTXH0(nData);
0006cc  e3a01205          MOV      r1,#0x50000000
0006d0  e5c14020          STRB     r4,[r1,#0x20]
0006d4  ea000032          B        |L1.1956|
                  |L1.1752|
;;;417        }
;;;418        else if(f_nWhichUart==1)
0006d8  e59f0338          LDR      r0,|L1.2584|
0006dc  e5900000          LDR      r0,[r0,#0]  ; f_nWhichUart
0006e0  e3500001          CMP      r0,#1
0006e4  1a000015          BNE      |L1.1856|
;;;419        {
;;;420            if(nData=='\n')
0006e8  e354000a          CMP      r4,#0xa
0006ec  1a000009          BNE      |L1.1816|
;;;421            {
;;;422                while(!(rUTRSTAT1 & 0x2));
0006f0  e1a00000          MOV      r0,r0
                  |L1.1780|
0006f4  e51f0318          LDR      r0,|L1.996|
0006f8  e5900010          LDR      r0,[r0,#0x10]
0006fc  e3100002          TST      r0,#2
000700  0afffffb          BEQ      |L1.1780|
;;;423                delay(10);					//because the slow response of hyper_terminal 
000704  e3a0000a          MOV      r0,#0xa
000708  ebfffffe          BL       delay
;;;424                rUTXH1 = '\r';
00070c  e3a0000d          MOV      r0,#0xd
000710  e51f1334          LDR      r1,|L1.996|
000714  e5c10020          STRB     r0,[r1,#0x20]
                  |L1.1816|
;;;425            }
;;;426            while(!(rUTRSTAT1 & 0x2));		//Wait until THR is empty.
000718  e1a00000          MOV      r0,r0
                  |L1.1820|
00071c  e51f0340          LDR      r0,|L1.996|
000720  e5900010          LDR      r0,[r0,#0x10]
000724  e3100002          TST      r0,#2
000728  0afffffb          BEQ      |L1.1820|
;;;427            delay(10);
00072c  e3a0000a          MOV      r0,#0xa
000730  ebfffffe          BL       delay
;;;428            rUTXH1 = nData;
000734  e51f1358          LDR      r1,|L1.996|
000738  e5c14020          STRB     r4,[r1,#0x20]
00073c  ea000018          B        |L1.1956|
                  |L1.1856|
;;;429        }   
;;;430        else if(f_nWhichUart==2)
000740  e59f02d0          LDR      r0,|L1.2584|
000744  e5900000          LDR      r0,[r0,#0]  ; f_nWhichUart
000748  e3500002          CMP      r0,#2
00074c  1a000014          BNE      |L1.1956|
;;;431        {
;;;432            if(nData=='\n')
000750  e354000a          CMP      r4,#0xa
000754  1a000009          BNE      |L1.1920|
;;;433            {
;;;434                while(!(rUTRSTAT2 & 0x2));
000758  e1a00000          MOV      r0,r0
                  |L1.1884|
00075c  e51f037c          LDR      r0,|L1.1000|
000760  e5900010          LDR      r0,[r0,#0x10]
000764  e3100002          TST      r0,#2
000768  0afffffb          BEQ      |L1.1884|
;;;435                delay(10);					//because the slow response of hyper_terminal 
00076c  e3a0000a          MOV      r0,#0xa
000770  ebfffffe          BL       delay
;;;436                rUTXH2 = '\r';
000774  e3a0000d          MOV      r0,#0xd
000778  e51f1398          LDR      r1,|L1.1000|
00077c  e5c10020          STRB     r0,[r1,#0x20]
                  |L1.1920|
;;;437            }
;;;438            while(!(rUTRSTAT2 & 0x2));		//Wait until THR is empty.
000780  e1a00000          MOV      r0,r0
                  |L1.1924|
000784  e51f03a4          LDR      r0,|L1.1000|
000788  e5900010          LDR      r0,[r0,#0x10]
00078c  e3100002          TST      r0,#2
000790  0afffffb          BEQ      |L1.1924|
;;;439            delay(10);
000794  e3a0000a          MOV      r0,#0xa
000798  ebfffffe          BL       delay
;;;440            rUTXH2 = nData;
00079c  e51f13bc          LDR      r1,|L1.1000|
0007a0  e5c14020          STRB     r4,[r1,#0x20]
                  |L1.1956|
;;;441        }       
;;;442    }               
0007a4  e8bd4010          POP      {r4,lr}
0007a8  e12fff1e          BX       lr
;;;443    
                          ENDP

                  uart_sendstring PROC
;;;452    void uart_sendstring(char *pString)
;;;453    {
0007ac  e92d4010          PUSH     {r4,lr}
0007b0  e1a04000          MOV      r4,r0
;;;454        while(*pString)
0007b4  ea000001          B        |L1.1984|
                  |L1.1976|
;;;455            uart_sendbyte(*pString++);
0007b8  e4d40001          LDRB     r0,[r4],#1
0007bc  ebfffffe          BL       uart_sendbyte
                  |L1.1984|
0007c0  e5d40000          LDRB     r0,[r4,#0]            ;454
0007c4  e3500000          CMP      r0,#0                 ;454
0007c8  1afffffa          BNE      |L1.1976|
;;;456    }
0007cc  e8bd4010          POP      {r4,lr}
0007d0  e12fff1e          BX       lr
;;;457    
                          ENDP

                  uart_printf PROC
;;;466    void uart_printf(char *fmt,...)
;;;467    {
0007d4  e92d000f          PUSH     {r0-r3}
0007d8  e52de004          PUSH     {lr}
0007dc  e24ddf41          SUB      sp,sp,#0x104
;;;468        va_list ap;
;;;469        char pString[256];
;;;470    
;;;471        va_start(ap,fmt);
0007e0  e28d0f43          ADD      r0,sp,#0x10c
0007e4  e58d0100          STR      r0,[sp,#0x100]
;;;472        vsprintf(pString,fmt,ap);
0007e8  e59d1108          LDR      r1,[sp,#0x108]
0007ec  e59d2100          LDR      r2,[sp,#0x100]
0007f0  e28d0000          ADD      r0,sp,#0
0007f4  ebfffffe          BL       __c89vsprintf
;;;473        uart_sendstring(pString);
0007f8  e28d0000          ADD      r0,sp,#0
0007fc  ebfffffe          BL       uart_sendstring
;;;474        va_end(ap);
;;;475    }
000800  e28ddf41          ADD      sp,sp,#0x104
000804  e49de014          LDR      lr,[sp],#0x14
000808  e12fff1e          BX       lr
;;;476    
                          ENDP

                  uart_getstring PROC
;;;302    void uart_getstring(char *pString)
;;;303    {
00080c  e92d4070          PUSH     {r4-r6,lr}
000810  e1a04000          MOV      r4,r0
;;;304        char *string2 = pString;
000814  e1a06004          MOV      r6,r4
;;;305        char c;
;;;306        while((c = uart_getch())!='\r')
000818  ea00000a          B        |L1.2120|
                  |L1.2076|
;;;307        {
;;;308            if(c=='\b')
00081c  e3550008          CMP      r5,#8
000820  1a000005          BNE      |L1.2108|
;;;309            {
;;;310                if( (int)string2 < (int)pString )
000824  e1560004          CMP      r6,r4
000828  aa000006          BGE      |L1.2120|
;;;311                {
;;;312                    uart_printf("\b \b");
00082c  e28f0f7a          ADR      r0,|L1.2588|
000830  ebfffffe          BL       uart_printf
;;;313                    pString--;
000834  e2444001          SUB      r4,r4,#1
000838  ea000002          B        |L1.2120|
                  |L1.2108|
;;;314                }
;;;315            }
;;;316            else 
;;;317            {
;;;318                *pString++ = c;
00083c  e4c45001          STRB     r5,[r4],#1
;;;319                uart_sendbyte(c);
000840  e1a00005          MOV      r0,r5
000844  ebfffffe          BL       uart_sendbyte
                  |L1.2120|
000848  ebfffffe          BL       uart_getch
00084c  e1a05000          MOV      r5,r0                 ;306
000850  e350000d          CMP      r0,#0xd               ;306
000854  1afffff0          BNE      |L1.2076|
;;;320            }
;;;321        }
;;;322        *pString='\0';
000858  e3a00000          MOV      r0,#0
00085c  e5c40000          STRB     r0,[r4,#0]
;;;323        uart_sendbyte('\n');
000860  e3a0000a          MOV      r0,#0xa
000864  ebfffffe          BL       uart_sendbyte
;;;324    }
000868  e8bd4070          POP      {r4-r6,lr}
00086c  e12fff1e          BX       lr
;;;325    
                          ENDP

                  uart_getintnum PROC
;;;336    int uart_getintnum(void)
;;;337    {
000870  e92d43f0          PUSH     {r4-r9,lr}
000874  e24dd024          SUB      sp,sp,#0x24
;;;338        char str[30];
;;;339        char *pString = str;
000878  e28d4004          ADD      r4,sp,#4
;;;340        int base     = 10;
00087c  e3a0500a          MOV      r5,#0xa
;;;341        int minus    = 0;
000880  e3a06000          MOV      r6,#0
;;;342        int nResult   = 0;
000884  e3a07000          MOV      r7,#0
;;;343        int lastIndex;    
;;;344        int i;
;;;345        
;;;346        uart_getstring(pString);
000888  e1a00004          MOV      r0,r4
00088c  ebfffffe          BL       uart_getstring
;;;347        
;;;348        if(pString[0]=='-')
000890  e5d40000          LDRB     r0,[r4,#0]
000894  e350002d          CMP      r0,#0x2d
000898  1a000001          BNE      |L1.2212|
;;;349        {
;;;350            minus = 1;
00089c  e3a06001          MOV      r6,#1
;;;351            pString++;
0008a0  e2844001          ADD      r4,r4,#1
                  |L1.2212|
;;;352        }
;;;353        
;;;354        if(pString[0]=='0' && (pString[1]=='x' || pString[1]=='X'))
0008a4  e5d40000          LDRB     r0,[r4,#0]
0008a8  e3500030          CMP      r0,#0x30
0008ac  1a000007          BNE      |L1.2256|
0008b0  e5d40001          LDRB     r0,[r4,#1]
0008b4  e3500078          CMP      r0,#0x78
0008b8  0a000002          BEQ      |L1.2248|
0008bc  e5d40001          LDRB     r0,[r4,#1]
0008c0  e3500058          CMP      r0,#0x58
0008c4  1a000001          BNE      |L1.2256|
                  |L1.2248|
;;;355        {
;;;356            base    = 16;
0008c8  e3a05010          MOV      r5,#0x10
;;;357            pString += 2;
0008cc  e2844002          ADD      r4,r4,#2
                  |L1.2256|
;;;358        }
;;;359        
;;;360        lastIndex = strlen(pString) - 1;
0008d0  e1a00004          MOV      r0,r4
0008d4  ebfffffe          BL       strlen
0008d8  e2408001          SUB      r8,r0,#1
;;;361        
;;;362        if(lastIndex<0)
0008dc  e3580000          CMP      r8,#0
0008e0  aa000003          BGE      |L1.2292|
;;;363            return -1;
0008e4  e3e00000          MVN      r0,#0
                  |L1.2280|
0008e8  e28dd024          ADD      sp,sp,#0x24
0008ec  e8bd43f0          POP      {r4-r9,lr}
;;;364        
;;;365        if(pString[lastIndex]=='h' || pString[lastIndex]=='H' )
;;;366        {
;;;367            base = 16;
;;;368            pString[lastIndex] = 0;
;;;369            lastIndex--;
;;;370        }
;;;371    
;;;372        if(base==10)
;;;373        {
;;;374            nResult = atoi(pString);
;;;375            nResult = minus ? (-1*nResult):nResult;
;;;376        }
;;;377        else
;;;378        {
;;;379            for(i=0;i<=lastIndex;i++)
;;;380            {
;;;381                if(isalpha(pString[i]))
;;;382                {
;;;383                    if(isupper(pString[i]))
;;;384                        nResult = (nResult<<4) + pString[i] - 'A' + 10;
;;;385                    else
;;;386                        nResult = (nResult<<4) + pString[i] - 'a' + 10;
;;;387                }
;;;388                else
;;;389                    nResult = (nResult<<4) + pString[i] - '0';
;;;390            }
;;;391            nResult = minus ? (-1*nResult):nResult;
;;;392        }
;;;393        return nResult;
;;;394    }
0008f0  e12fff1e          BX       lr
                  |L1.2292|
0008f4  e7d40008          LDRB     r0,[r4,r8]            ;365
0008f8  e3500068          CMP      r0,#0x68              ;365
0008fc  0a000002          BEQ      |L1.2316|
000900  e7d40008          LDRB     r0,[r4,r8]            ;365
000904  e3500048          CMP      r0,#0x48              ;365
000908  1a000003          BNE      |L1.2332|
                  |L1.2316|
00090c  e3a05010          MOV      r5,#0x10              ;367
000910  e3a00000          MOV      r0,#0                 ;368
000914  e7c40008          STRB     r0,[r4,r8]            ;368
000918  e2488001          SUB      r8,r8,#1              ;369
                  |L1.2332|
00091c  e355000a          CMP      r5,#0xa               ;372
000920  1a000009          BNE      |L1.2380|
000924  e1a00004          MOV      r0,r4                 ;374
000928  ebfffffe          BL       atoi
00092c  e1a07000          MOV      r7,r0                 ;374
000930  e3560000          CMP      r6,#0                 ;375
000934  0a000001          BEQ      |L1.2368|
000938  e2670000          RSB      r0,r7,#0              ;375
00093c  ea000000          B        |L1.2372|
                  |L1.2368|
000940  e1a00007          MOV      r0,r7                 ;375
                  |L1.2372|
000944  e1a07000          MOV      r7,r0                 ;375
000948  ea000021          B        |L1.2516|
                  |L1.2380|
00094c  e3a09000          MOV      r9,#0                 ;379
000950  ea000017          B        |L1.2484|
                  |L1.2388|
000954  ebfffffe          BL       __rt_ctype_table
000958  e5900000          LDR      r0,[r0,#0]            ;381
00095c  e7d41009          LDRB     r1,[r4,r9]            ;381
000960  e7d00001          LDRB     r0,[r0,r1]            ;381
000964  e3100098          TST      r0,#0x98              ;381
000968  0a00000d          BEQ      |L1.2468|
00096c  ebfffffe          BL       __rt_ctype_table
000970  e5900000          LDR      r0,[r0,#0]            ;383
000974  e7d41009          LDRB     r1,[r4,r9]            ;383
000978  e7d00001          LDRB     r0,[r0,r1]            ;383
00097c  e3100010          TST      r0,#0x10              ;383
000980  0a000003          BEQ      |L1.2452|
000984  e7d40009          LDRB     r0,[r4,r9]            ;384
000988  e0800207          ADD      r0,r0,r7,LSL #4       ;384
00098c  e2407037          SUB      r7,r0,#0x37           ;384
000990  ea000006          B        |L1.2480|
                  |L1.2452|
000994  e7d40009          LDRB     r0,[r4,r9]            ;386
000998  e0800207          ADD      r0,r0,r7,LSL #4       ;386
00099c  e2407057          SUB      r7,r0,#0x57           ;386
0009a0  ea000002          B        |L1.2480|
                  |L1.2468|
0009a4  e7d40009          LDRB     r0,[r4,r9]            ;389
0009a8  e0800207          ADD      r0,r0,r7,LSL #4       ;389
0009ac  e2407030          SUB      r7,r0,#0x30           ;389
                  |L1.2480|
0009b0  e2899001          ADD      r9,r9,#1              ;379
                  |L1.2484|
0009b4  e1590008          CMP      r9,r8                 ;379
0009b8  daffffe5          BLE      |L1.2388|
0009bc  e3560000          CMP      r6,#0                 ;391
0009c0  0a000001          BEQ      |L1.2508|
0009c4  e2670000          RSB      r0,r7,#0              ;391
0009c8  ea000000          B        |L1.2512|
                  |L1.2508|
0009cc  e1a00007          MOV      r0,r7                 ;391
                  |L1.2512|
0009d0  e1a07000          MOV      r7,r0                 ;391
                  |L1.2516|
0009d4  e1a00007          MOV      r0,r7                 ;393
0009d8  eaffffc2          B        |L1.2280|
;;;395    
                          ENDP

                  timer_start PROC
;;;486    {
;;;487        rWTCON = ((PCLK/1000000-1)<<8)|(divider<<3); //Watch-dog timer control register
0009dc  e3a01c31          MOV      r1,#0x3100
0009e0  e1811180          ORR      r1,r1,r0,LSL #3
0009e4  e3a02453          MOV      r2,#0x53000000
0009e8  e5821000          STR      r1,[r2,#0]
;;;488        rWTDAT = 0xffff;							 //Watch-dog timer data register
0009ec  e51f1638          LDR      r1,|L1.956|
0009f0  e5821004          STR      r1,[r2,#4]
;;;489        rWTCNT = 0xffff;							 //Watch-dog count register
0009f4  e5821008          STR      r1,[r2,#8]
;;;490    
;;;491        rWTCON = rWTCON | (1<<5) | ~(1<<2);  		 //May 06, 2002 SOP
0009f8  e3a01453          MOV      r1,#0x53000000
0009fc  e5911000          LDR      r1,[r1,#0]
000a00  e3811020          ORR      r1,r1,#0x20
000a04  e3e02004          MVN      r2,#4
000a08  e1811002          ORR      r1,r1,r2
000a0c  e3a02453          MOV      r2,#0x53000000
000a10  e5821000          STR      r1,[r2,#0]
;;;492    }
000a14  e12fff1e          BX       lr
                  |L1.2584|
000a18  00000000          DCD      f_nWhichUart
                  |L1.2588|
000a1c  08200800          DCB      "\b \b",0
                          ENDP

                  timer_stop PROC
;;;503    {
;;;504        rWTCON = ((PCLK/1000000-1)<<8);
000a20  e3a00c31          MOV      r0,#0x3100
000a24  e3a01453          MOV      r1,#0x53000000
000a28  e5810000          STR      r0,[r1,#0]
;;;505        return (0xffff - rWTCNT);
000a2c  e3a00453          MOV      r0,#0x53000000
000a30  e5900008          LDR      r0,[r0,#8]
000a34  e51f1680          LDR      r1,|L1.956|
000a38  e0410000          SUB      r0,r1,r0
;;;506    }
000a3c  e12fff1e          BX       lr
;;;507    
                          ENDP

                  change_value_MPLL PROC
;;;517    {
;;;518        rMPLLCON = (nMdiv<<12) | (nPdiv<<4) | nSdiv;
000a40  e1a03600          LSL      r3,r0,#12
000a44  e1833201          ORR      r3,r3,r1,LSL #4
000a48  e1833002          ORR      r3,r3,r2
000a4c  e3a0c313          MOV      r12,#0x4c000000
000a50  e58c3004          STR      r3,[r12,#4]
;;;519    }
000a54  e12fff1e          BX       lr
;;;520    
                          ENDP

                  change_clock_divider PROC
;;;535         //     1,1         1:2:4
;;;536        rCLKDIVN = (nHdiv<<1) | nPdiv;    
000a58  e1812080          ORR      r2,r1,r0,LSL #1
000a5c  e3a03313          MOV      r3,#0x4c000000
000a60  e5832014          STR      r2,[r3,#0x14]
;;;537        
;;;538    }
000a64  e12fff1e          BX       lr
;;;539    
                          ENDP

                  ChangeUPllValue PROC
;;;549    {
;;;550        rUPLLCON = (nMdiv<<12) | (nPdiv<<4) | nSdiv;
000a68  e1a03600          LSL      r3,r0,#12
000a6c  e1833201          ORR      r3,r3,r1,LSL #4
000a70  e1833002          ORR      r3,r3,r2
000a74  e3a0c313          MOV      r12,#0x4c000000
000a78  e58c3008          STR      r3,[r12,#8]
;;;551    }
000a7c  e12fff1e          BX       lr
;;;552    
                          ENDP

                  EnableMMU PROC
;;;600    
;;;601    	ctl = ARM_ReadControl();
000a80  e1a00000          MOV      r0,r0
000a84  ee110f10          MRC      p15,#0x0,r0,c1,c0,#0
000a88  e1a00000          MOV      r0,r0
000a8c  e1a01000          MOV      r1,r0
;;;602    	ctl |= (1 << 0);
000a90  e3811001          ORR      r1,r1,#1
;;;603    	ARM_WriteControl(ctl);
000a94  e1a00000          MOV      r0,r0
000a98  ee011f10          MCR      p15,#0x0,r1,c1,c0,#0
000a9c  e1a00000          MOV      r0,r0
;;;604    }
000aa0  e12fff1e          BX       lr
;;;605    
                          ENDP

                  InitMMU PROC
;;;614    void InitMMU(unsigned int *pTranslationTable)
;;;615    {
000aa4  e92d4010          PUSH     {r4,lr}
000aa8  e1a03000          MOV      r3,r0
000aac  e1a00723          LSR      r0,r3,#14
000ab0  e1a00700          LSL      r0,r0,#14
000ab4  ee020f10          MCR      p15,#0x0,r0,c2,c0,#0
000ab8  e1a00000          MOV      r0,r0
;;;616    	int i;
;;;617    	// Program the TTB
;;;618    	ARM_WriteTTB((unsigned int) pTranslationTable);
;;;619    	// Program the domain access register
;;;620    	ARM_WriteDomain(0xC0000000); 		// domain 15: access are not checked
000abc  e1a00000          MOV      r0,r0
000ac0  e3a00103          MOV      r0,#0xc0000000
000ac4  ee030f10          MCR      p15,#0x0,r0,c3,c0,#0
000ac8  e1a00000          MOV      r0,r0
;;;621    
;;;622    	// Reset table entries
;;;623    	for (i = 0; i < 0x200; ++i)
000acc  e3a04000          MOV      r4,#0
000ad0  ea000002          B        |L1.2784|
                  |L1.2772|
;;;624    		pTranslationTable[i] = 0;
000ad4  e3a00000          MOV      r0,#0
000ad8  e7830104          STR      r0,[r3,r4,LSL #2]
000adc  e2844001          ADD      r4,r4,#1              ;623
                  |L1.2784|
000ae0  e3540c02          CMP      r4,#0x200             ;623
000ae4  bafffffa          BLT      |L1.2772|
;;;625    
;;;626    	// Program level 1 page table entry
;;;627    	pTranslationTable[0x0] =
000ae8  e59f0054          LDR      r0,|L1.2884|
000aec  e5830000          STR      r0,[r3,#0]
;;;628    		(0x300 << 20) |  				// Physical Address
;;;629    		(1 << 10) |      				// Access in supervisor mode
;;;630    		(15 << 5) |      				// Domain
;;;631    		1 << 4 |
;;;632    		0x2;             				// Set as 1 Mbyte section
;;;633    	pTranslationTable[0x1] =
000af0  e2800601          ADD      r0,r0,#0x100000
000af4  e5830004          STR      r0,[r3,#4]
;;;634    		(0x301 << 20) |  				// Physical Address
;;;635    		(1 << 10) |      				// Access in supervisor mode
;;;636    		(15 << 5) |      				// Domain
;;;637    		1 << 4 |
;;;638    		0x2;             				// Set as 1 Mbyte section
;;;639    	pTranslationTable[0x2] =
000af8  e2800601          ADD      r0,r0,#0x100000
000afc  e5830008          STR      r0,[r3,#8]
;;;640    		(0x302 << 20) |  				// Physical Address
;;;641    		(1 << 10) |      				// Access in supervisor mode
;;;642    		(15 << 5) |      				// Domain
;;;643    		1 << 4 |
;;;644    		0x2;             				// Set as 1 Mbyte section
;;;645    	pTranslationTable[0x3] =
000b00  e2800601          ADD      r0,r0,#0x100000
000b04  e583000c          STR      r0,[r3,#0xc]
;;;646    		(0x303 << 20) |  				// Physical Address
;;;647    		(1 << 10) |      				// Access in supervisor mode
;;;648    		(15 << 5) |      				// Domain
;;;649    		1 << 4 |
;;;650    		0x2;             				// Set as 1 Mbyte section
;;;651    
;;;652    	for(i = 0x200; i < 0xFFF; ++i)
000b08  e3a04c02          MOV      r4,#0x200
000b0c  ea000005          B        |L1.2856|
                  |L1.2832|
;;;653    		pTranslationTable[i] = 
000b10  e3a00b01          MOV      r0,#0x400
000b14  e1800a04          ORR      r0,r0,r4,LSL #20
000b18  e3800c01          ORR      r0,r0,#0x100
000b1c  e38000f2          ORR      r0,r0,#0xf2
000b20  e7830104          STR      r0,[r3,r4,LSL #2]
000b24  e2844001          ADD      r4,r4,#1              ;652
                  |L1.2856|
000b28  e59f0018          LDR      r0,|L1.2888|
000b2c  e1540000          CMP      r4,r0                 ;652
000b30  bafffff6          BLT      |L1.2832|
;;;654    			(i << 20) |  				// Physical Address
;;;655    			(1 << 10) |      			// Access in supervisor mode
;;;656    			(15 << 5) |      			// Domain
;;;657    			1 << 4 |
;;;658    			0x2;             			// Set as 1 Mbyte section
;;;659    
;;;660    	EnableMMU();		 				// Enable the MMU
000b34  ebfffffe          BL       EnableMMU
;;;661    }
000b38  e8bd4010          POP      {r4,lr}
000b3c  e12fff1e          BX       lr
;;;662    
                          ENDP

                  __gccmain PROC
;;;672    {
;;;673    }
000b40  e12fff1e          BX       lr
                          ENDP

                  |L1.2884|
000b44  300005f2          DCD      0x300005f2
                  |L1.2888|
000b48  00000fff          DCD      0x00000fff

                          AREA ||.data||, DATA, ALIGN=2

                  delayLoopCount
000000  000007ec          DCD      0x000007ec
                  f_nWhichUart
000004  00000000          DCD      0x00000000
                  ||Image$$RW_ZI$$ZI$$Limit||
000008  00                DCB      0x00
